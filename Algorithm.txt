// pass string into evaluator function

// check for balanced parentheses
if (isBalanced())
	continue processing string;
else
	return "Invalid expression: Expression contains unbalanced parentheses.";

// start tokenizing string
/* tokenizer: breaks string into operators & operands
	- recognize and handle spaces in input
	- multiple-digit integers
	- double-character operators
	- valid operator combinations / sequence of operators
	- converts operators to enumerated types
	- operands separated by operators
	- no sequence of integers separated by space(s)
*/

// evaluate 1st string token
if (1stToken == NOT || INC || DEC || NEG || OPEN || int)
	1stTokenOK == true;
	push token to operator stack;
	lastPushed = unaryOperator || operand;
else 
	return "Invalid expression: Expression cannot start with a binary operator.";

// valid 1st token and balanced parentheses; continue processing string
while (there are more tokens in the string) {
	// Analyze next token
	if (token == operator) {
		// analyze the operator
		if (operator == +) {
			check the next character
			if (nextchar == '+')
				operator == INC
				push operator to operator stack
				lastPushed = unairyOperator
			if (nextchar == ' ' || nextchar == digit || nextchar == '-' || '(')
				operator = ADD
				// compare operator to top of operator stack
				push operator to operator stack
				lastPushed = binaryOperator
			
		
		
		if (lastPushed == operator)
			return "Invalid expression: Expression missing an operand."
		else {
			// compare current operator precidence with precidence of top operator in the stack
			// if operator > top of operator stack, push to stack
			if (currOperator->precidence > topOperator->precidence){
				push to operator stack;
			}
			// otherwise, process all operators of equal or greater predicence to current operator from the stack
			else {
				while (currOperator->precidence <= topOperator->precidence && operatorStack != empty)
				process stacks
			}
		set lastPushed = binaryOperator || unaryOperator;
		}

	if (token == operand) {
		if (lastPushed == operand)
			return "Invalid expression: Expression missing an operator."
		else {
			push to operand stack;
			set lastPushedType = operand
		}
	}



	

// output final result








// all functions below need to be updated from their current
// form to include ALL string parsing and error checking rules

/* *** String Tokenizer ************************************
istringstream tokens(expression);
char next_char;
while (tokens >> next_char) {
	if (isdigit(next_char)) {
		tokens.putback(next_char);
    int value;
    tokens >> value;
    operand_stack.push(value);
} else if (is_operator(next_char)) {
    int result = eval_op(next_char);
    operand_stack.push(result);
} else {
    throw Syntax_Error("Invalid character encountered");
    }
}
if (!operand_stack.empty()) {
	int answer = operand_stack.top();
    operand_stack.pop();
    if (operand_stack.empty()) {
		return answer;
    } else {
		throw Syntax_Error("Stack should be empty");
    }
} else {
    throw Syntax_Error("Stack is empty");
	}
}
***********************************************************/

/* *** Expression Evaluator Functions **********************
// Ensure an empty stack
int Postfix_Evaluator::eval(const std::string& expression) {
while (!operand_stack.empty())
	operand_stack.pop();

// Evaluate an expression
int Infix_Evaluator::eval_op(char op) {
	
	if (operand_stack.empty()) 
		throw Syntax_Error("Stack is empty");
	int rhs = operand_stack.top();
	operand_stack.pop();
	
	if (operand_stack.empty())
		throw Syntax_Error("Stack is empty");
	int lhs = operand_stack.top();
	operand_stack.pop();
	
	int result = 0;
	switch(op) {
	case 'ADD' : result = lhs + rhs;
				break;
	case 'SUB' : result = lhs - rhs;
				break;
	case 'MUL' : result = lhs * rhs;
				break;
	case 'DIV' : result = lhs / rhs;
				break;
	case 'MOD' : result = lhs % rhs;
				break;
	}
	return result;
}

// Output last item on stack as final answer
if (!operand_stack.empty()) {
	
	int answer = operand_stack.top();
	operand_stack.pop();
    
	if (operand_stack.empty()) {
		return answer;
    } else {
		throw Syntax_Error("Stack should be empty");
    }
} else {
    throw Syntax_Error("Stack is empty");
  }
}

***********************************************************/